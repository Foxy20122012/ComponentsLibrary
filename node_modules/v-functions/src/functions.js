import { format, parseISO, parse, isBefore } from 'date-fns'
import * as numeral from 'numeral'
import accounting from 'accounting'
import pako from 'pako'

// encode storage
import forge from 'node-forge'
const encryptKey = 'eyJhIjoiM2g6LGYiLCJlIjoiLD15azkiLCJpIjoiRy52PVIiLCJvIjoiaCw6bkEiLCJ1Ijoiem46VkAiLCJfMiI6Imo9OmNCIiwiTSI6InJkLFQ7IiwiUSI6InhsOkQsIiwiXzgiOiJmLixrWSJ9'

let _selfFunctions = null

// registra formato para uso con símbolo de quetzales Q
// para que no dependa del locales en formato currency
if (!numeral['format' + 's']['monedaq2']) {
  numeral.register('format', 'monedaq2', {
    regexps: {
      format: /(Q)/,
      unformat: /(Q)/
    },
    format: function (value, format, roundingFunction) {
      var space = '',
        output;

      output = numeral._.numberToFormat(value, format, roundingFunction);

      if (numeral._.includes(output, ')')) {
        output = output.split('');

        output.splice(-1, 0);

        output = 'Q' + output.join('');
      } else {
        output = 'Q' + output;
      }

      return output;
    },
    unformat: function (string) {
      return numeral._.stringToNumber(string) * 0.01;
    }
  });
}

if (!numeral['format' + 's']['porc2']) {
  numeral.register('format', 'porc2', {
    regexps: {
      format: /(%)/,
      unformat: /(%)/
    },
    format: function (value, format, roundingFunction) {
      var space = '',
        output;

      output = numeral._.numberToFormat(value, format, roundingFunction);

      if (numeral._.includes(output, ')')) {
        output = output.split('');

        output.splice(-1, 0);

        output = output.join('') + '%';
      } else {
        output = output + '%';
      }

      return output;
    },
    unformat: function (string) {
      return numeral._.stringToNumber(string) * 0.01;
    }
  });
}

const functions = {

  initialize: function () {
    window.functions = this
    _selfFunctions = this
  },

  invertLabelColor: function (color) {
    const rgb = this.colorToRgb(color)
    const threshold = 40 // 140;
    const luminance = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b
    return luminance > threshold ? '#000000' : '#ffffff'
  },

  colorToRgb: function (color) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    let resultformat
    if (color.indexOf("#") >= 0) {
      const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i
      color = color.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b
      })

      result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color)
      result = {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      }
    } else if (color.indexOf("rgba") >= 0) {
      color = color.replace("rgba(", "").replace(")", "")
      result = color.split(",")
      result = {
        r: parseInt(result[0], 10),
        g: parseInt(result[1], 10),
        b: parseInt(result[2], 10)
      }
    } else if (color.indexOf("rgb") >= 0) {
      color = color.replace("rgb(", "").replace(")", "")
      result = color.split(",")
      result = {
        r: parseInt(result[0], 10),
        g: parseInt(result[1], 10),
        b: parseInt(result[2], 10)
      }
    }

    return result || null
  },

  padDigits: function (number, digits) {
    return Array(Math.max(digits - String(number).length + 1, 0)).join(0) + number
  },
  
  padString: function (text, digits, character) {
    const padCount = Math.abs(digits)
    if (digits === 0 || isNaN(padCount)) {
      return text
    }
    if (!text || text.length <= 0) {
      return Array(padCount).join(character)
    }
    if (text.length >= padCount) {
      return text
    }
    if (digits < 0) {
      return text + Array(Math.max(padCount - text.length + 1, 0)).join(character)
    }
    return Array(Math.max(padCount - text.length + 1, 0)).join(character) + text
  },

  removeSpace: function (text) {
    let outString = ""
    // separador = " ", // un espacio en blanco
    const arrayString = text.split(" ")
    let x
    for (x in arrayString) {
      outString += arrayString[x]
    }     
    return (outString)
  },

  centerString: function (text, lineLength) {
    if (lineLength <= 0) {
      return text
    }
    if (!text || text.length <= 0) {
      return this.padString("", lineLength, " ")
    }
    if (text.length >= lineLength) {
      return text
    }
    return this.padString(text, lineLength - Math.floor((lineLength - text.length) / 2), " ")
  },

  toUpperCaseAndTrim: function (val) {
    if (val !== null && val !== undefined) {
      val = val.toString()
      return val.toUpperCase().trim()
    }
    return val
  },

  trim: function (val) {
    if (val != null) {
      val = val.toString()
      return val.trim()
    }
    return val
  },

  removeWhitespace: function (val, separador = null) {
    if (val != null) {
      val = val.toString().trim();
      if (separador == null) separador = '';
      return val.replace(/\s+/g, separador);
    }
    return val
  },

  removeWhitespaceUpper: function (val, separador = null) {
    if (val != null) {
      val = val.toString().trim();
      if (separador == null) separador = '';
      return val.replace(/\s+/g, separador).toUpperCase();
    }
    return val
  },
  
  formatMoney: function (val, showTextOnNull = false, textOnNull) {
    if (val) {
      return numeral(val).format('0,0.00')
    }
    if (showTextOnNull === true) {
      return textOnNull ? textOnNull : 'Vacío/En Blanco'
    }
    return val
  },

  format4decimales: function (val, showTextOnNull = false, textOnNull) {
    if (val) {
      return numeral(val).format('0,0.0000')
    }
    if (showTextOnNull === true) {
      return textOnNull ? textOnNull : 'Vacío/En Blanco'
    }
    return val
  },

  formatHour: function (val, showTextOnNull = false, textOnNull) {
    if (val) {
      return format(val, 'HH:mm')
    }
    if (showTextOnNull === true) {
      return textOnNull ? textOnNull : 'Vacío/En Blanco'
    }
    return val
  },

  formatDateTimeGMT (val, seconds = false, showTextOnNull = false, textOnNull) {
    if (val) {
      const time = parseISO(val)
      return format(time, "dd/MM/yyyy HH:mm" + (seconds === true ? ":ss" : ""))
    }
    if (showTextOnNull === true) {
      return textOnNull ? textOnNull : 'Vacío/En Blanco'
    }
    return val
  },

  formatDate: function (val, formatStyle, showTextOnNull = false, textOnNull) {
    if (typeof formatStyle !== "undefined" && formatStyle.length > 0) {
      if (typeof val !== "undefined" && val !== null && (String(val)).length > 0) {
        if (val instanceof Date) {
          return format(val, formatStyle)
        } else {
          const time = parseISO(val) // lo convierte a fecha asume isodate
          return format(time, formatStyle)
        }
      }
    }
    if (!val || val === null) {
      if (showTextOnNull === true) {
        return textOnNull ? textOnNull : 'Vacío/En Blanco'
      }
    }
    return val
  },

  formatOrder: function (val, showTextOnNull = false, textOnNull) {
    if (val && val !== null) {
      return numeral(val).format('0.0')
    }
    return val
  },

  formatPercent: function (val, format, showTextOnNull = false, textOnNull) {
    if (typeof format !== "undefined" && format.length > 0) {
      if (typeof val !== "undefined" && val !== null && (String(val)).length > 0) {
        let precision = 2
        if (format.includes('.')) {
          const formatParts = format.split('.')
          if (formatParts && formatParts !== null && formatParts[1] && formatParts[1] !== null) {
            const rightPart = formatParts[1]
            let digitCounter = 0
            while (digitCounter < rightPart.length && rightPart[digitCounter].includes('0')) {
              digitCounter++
              precision = digitCounter
            }
          }
        }
        return accounting.formatMoney(val, '%', precision, ',', '.', '%v%s')
      }
    }
    if (!val || val === null) {
      if (showTextOnNull === true) {
        return textOnNull ? textOnNull : 'Vacío/En Blanco'
      }
    }
    return val
  },

  formatNumber: function (val, format, showTextOnNull = false, textOnNull) {
    let functionsFunc = null
    if (window) {
      functionsFunc = window.functions
    }
    if (_selfFunctions) {
      functionsFunc = _selfFunctions
    }
    if (typeof format !== "undefined" && format.length > 0) {
      if (typeof val !== "undefined" && val !== null && (String(val)).length > 0) {
        if (format.includes('%')) {
          return functionsFunc.formatPercent(val, format, showTextOnNull, textOnNull)
        }
        return numeral(val).format(format)
      }
    }
    if (!val || val === null) {
      if (showTextOnNull === true) {
        return textOnNull ? textOnNull : 'Vacío/En Blanco'
      }
    }
    return val
  },

  formatedValue: function (val, format, type, showTextOnNull = false, textOnNull) {
    let functionsFunc = null
    if (window) {
      functionsFunc = window.functions
    }
    if (_selfFunctions) {
      functionsFunc = _selfFunctions
    }
    if (type === "number") {
      return functionsFunc.formatNumber(val, format, showTextOnNull, textOnNull)
    } else if (type === "date" || type === "datetime") {
      return functionsFunc.formatDate(val, format, showTextOnNull, textOnNull)
    } 
    if (!val || val === null) {
      if (showTextOnNull === true) {
        return textOnNull ? textOnNull : 'Vacío/En Blanco'
      }
    }
    return val
  },

  unformatedValue: function (val, format, type, showTextOnNull = false, textOnNull) {
    if (showTextOnNull === true) {
      if (val) {
        if (val === textOnNull || val === 'Vacío/En Blanco') {
          return null
        }
      }
    }
    if (typeof format !== "undefined" && format.length > 0) {
      if (typeof val !== "undefined" && val !== null && (String(val)).length > 0) {
        if (type === "number") {
          return numeral(val, format).value()
        } else if (type === "date" || type === "datetime") {
          return parse(val, format, new Date())
        }
      }
    }

    return val
  },

  getExtension (fileName) {
    if (!fileName) {
      return ""
    }
    return fileName.substring(fileName.lastIndexOf(".") + 1)
  },

  getNameFile (fileName, ext) {
    if (!fileName) {
      return ""
    }
    const nameFile = (fileName.substr(0, fileName.lastIndexOf("."))).toUpperCase()
    const datetime = format(new Date(), 'yyyyMMddHHmmss')
    const nameFull = nameFile + '_' + datetime + '.' + ext
    return nameFull
  },

  getFilePattern (filename) {
    if (filename && filename != null) {
      const fileExtensionPattern = /\.([0-9a-z]+)(?=[?#])|(\.)(?:[\w]+)$/gmi
      let extension = filename.match(fileExtensionPattern)
      if (Array.isArray(extension)) {
        extension = extension[0]
      }
      filename = filename.replace(new RegExp(extension + '$'), '')
      return {filename, extension}
    }
    return {filename: '', extension: ''}
  },

  verificarFechaVencimientoTC (fecha) {
    // verifica si la fecha de la tarjeta de crédito ya esta vencida: true si esta vencida
    // TODO: hacer validacion si solo debe devolver true o false, o bien "vencida" o "proxima a vencer"
    const ahora = new Date() 

    if (!fecha) { return false }
  
    if (fecha.length < 4) { return false }
    const fechainicial = parse(fecha, 'MMYY') 
        
    return isBefore(fechainicial, ahora)
  },

  base64toBlob: function (base64Data, contentType) {
    contentType = contentType || ''
    const sliceSize = 1024
    base64Data = base64Data.replace("data:" + contentType + ";base64,", "")
    // const byteCharacters = atob(base64Data)
    const byteCharacters = forge.util.encode64(base64Data)
    const bytesLength = byteCharacters.length
    const slicesCount = Math.ceil(bytesLength / sliceSize)
    const byteArrays = new Array(slicesCount)

    for (let sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
      const begin = sliceIndex * sliceSize
      const end = Math.min(begin + sliceSize, bytesLength)

      const bytes = new Array(end - begin)
      for (let offset = begin, i = 0; offset < end; ++i, ++offset) {
        bytes[i] = byteCharacters[offset].charCodeAt(0)
      }
      byteArrays[sliceIndex] = new Uint8Array(bytes)
    }

    let blob = null
    try {
      blob = new Blob(byteArrays, {
        type: contentType
      })
    } catch (e) {
      // TypeError old chrome and FF
      window.BlobBuilder = window.BlobBuilder ||
        window.WebKitBlobBuilder ||
        window.MozBlobBuilder ||
        window.MSBlobBuilder
      if (e.name === 'TypeError' && window.BlobBuilder) {
        const bb = new window.BlobBuilder()
        bb.append(byteArrays)
        blob = bb.getBlob(contentType)
      } else if (e.name === "InvalidStateError") {
        // InvalidStateError (tested on FF13 WinXP)
        blob = new Blob(byteArrays, {
          type: contentType
        })
      } else {
        // We're screwed, blob constructor unsupported entirely   
      }
    }

    return blob
  },
  
  // -------- Encode Storage
  setEncodeStorage (llave, valor) {
    // encode/decode base64
    // var encoded = forge.util.encode64(str);
    // var str = forge.util.decode64(encoded);
    try {
      if (llave == null || !llave) {
        console.error('functions encode storage, first parameter is null')
      } else {
        const llaveEncode = forge.util.encode64(llave.toString())
        const valorJsonString = JSON.stringify(valor)
        const valorEncode = forge.util.encode64(valorJsonString)
        const strK = forge.util.decode64(encryptKey)
        const objK = JSON.parse(strK)
        const valorEncode2 = valorEncode.replace('a', objK.a).replace('e', objK.e).replace('i', objK.i).replace('o', objK.o).replace('u', objK.u).replace('2', objK._2).replace('M', objK.M).replace('Q', objK.Q).replace('8', objK._8)
        localStorage.setItem(llaveEncode, valorEncode2)
      }
    } catch (e) {
      console.error('functions encode storage ,', e.message)
    }
  },
  getDecodeStorage (llave) {
    // encode/decode base64
    // var encoded = forge.util.encode64(str);
    // var str = forge.util.decode64(encoded);
    try {
      if (llave == null || !llave) {
        console.error('functions decode storage, first parameter is null')
      } else {
        const llaveEncode = forge.util.encode64(llave.toString())
        const valorEncode = localStorage.getItem(llaveEncode)
        if (valorEncode == null || !valorEncode) {
          return
        }
        const strK = forge.util.decode64(encryptKey)
        const objK = JSON.parse(strK)
        const valorEncode2 = valorEncode.replace(objK.a, 'a').replace(objK.e, 'e').replace(objK.i, 'i').replace(objK.o, 'o').replace(objK.u, 'u').replace(objK._2, '2').replace(objK.M, 'M').replace(objK.Q, 'Q').replace(objK._8, '8')
        const valorJsonString = forge.util.decode64(valorEncode2)
        return JSON.parse(valorJsonString)
      }
    } catch (e) {
      console.error('functions decode storage ,', e.message)
    }
  },
  // -------- Fin Encode Storage

  convertToJSON (dataRaw) {
    // convierte un objeto { cols: [<{objCol}>], rows: [<[data]>] }
    // a JSON [{ col: data, ... }]
    const rows = Array.isArray(dataRaw.data) ? dataRaw.data : dataRaw.rows 
    if (!Array.isArray(rows)) {
      return []
    }
    const data = rows.map((row) => {
      let json = {}
      row.forEach((val, idx) => {
        const obj = {}
        obj[dataRaw.cols[idx].id] = val
        json = Object.assign(json, obj)
      })
      return json
    })
    return data
  },
  
  // -------- Encode Key
  getEncodeKey (valueToEncode) {
    // encode/decode base64
    // var encoded = forge.util.encode64(str);
    // var str = forge.util.decode64(encoded);
    try {
      if (valueToEncode == null || !valueToEncode) {
        console.error('functions Encode Key, parameter is null')
        return null
      } else {
        const valorEncode = forge.util.encode64(valueToEncode)
        const strK = forge.util.decode64(encryptKey)
        const objK = JSON.parse(strK)
        const valorEncode2 = valorEncode.replace('a', objK.a).replace('e', objK.e).replace('i', objK.i).replace('o', objK.o).replace('u', objK.u).replace('2', objK._2).replace('M', objK.M).replace('Q', objK.Q).replace('8', objK._8)
        return valorEncode2
      }
    } catch (e) {
      console.error('functions encode Key ,', e.message)
      return null
    }
  },
  getDecodeKey (valueToDecode) {
    // encode/decode base64
    // var encoded = forge.util.encode64(str);
    // var str = forge.util.decode64(encoded);
    try {
      if (valueToDecode == null || !valueToDecode) {
        console.error('functions Decode Key, parameter is null')
      } else {
        const strK = forge.util.decode64(encryptKey)
        const objK = JSON.parse(strK)
        const valorEncode = valueToDecode.replace(objK.a, 'a').replace(objK.e, 'e').replace(objK.i, 'i').replace(objK.o, 'o').replace(objK.u, 'u').replace(objK._2, '2').replace(objK.M, 'M').replace(objK.Q, 'Q').replace(objK._8, '8')
        const valorDecodeResult = forge.util.decode64(valorEncode)
        return valorDecodeResult
      }
    } catch (e) {
      console.error('functions Decode Key ,', e.message)
    }
  },
  // -------- Fin Encode Key

  string2BufferArray (str) {
    const len = str.length
    const buf = new ArrayBuffer(len * 2)
    const bufView = new Uint8Array(buf)
    for (let idx = 0; idx < len; idx++) {
      bufView[idx] = str.charCodeAt(idx)
    }
    return bufView
  },
  
  // -------- Compresion de Objeto 
  decodeJsonDefinition (jsonDefinition) {
    if (jsonDefinition && jsonDefinition != null && jsonDefinition.length > 0) {
      jsonDefinition = forge.util.decode64(jsonDefinition)
      jsonDefinition = this.string2BufferArray(jsonDefinition)
      jsonDefinition = pako.inflate(jsonDefinition, { to: 'string' })
      jsonDefinition = JSON.parse(jsonDefinition) || {}
      return jsonDefinition
    }
    return {}
  },
  encodeJsonDefinition (OJsonDefinition) {
    if (OJsonDefinition && OJsonDefinition !== null && typeof OJsonDefinition === "object") {
      OJsonDefinition = JSON.stringify(OJsonDefinition)
      OJsonDefinition = pako.deflate(OJsonDefinition)
      OJsonDefinition = String.fromCharCode.apply(null, new Uint8Array(OJsonDefinition))
      OJsonDefinition = forge.util.encode64(OJsonDefinition)
      return OJsonDefinition
    }
    return null
  },
  // -------- Compresion de Objeto

  // -------- Compresion de String 
  compressString (valueToCompress) {
    if (valueToCompress !== undefined && valueToCompress !== null) {
      valueToCompress = pako.deflate(valueToCompress)
      valueToCompress = String.fromCharCode.apply(null, new Uint8Array(valueToCompress))
      valueToCompress = forge.util.encode64(valueToCompress)
      return valueToCompress
    }
    return ''
  },
  decompressString (valueToDecompress) {
    if (valueToDecompress !== undefined && valueToDecompress !== null) {
      valueToDecompress = forge.util.decode64(valueToDecompress)
      valueToDecompress = this.string2BufferArray(valueToDecompress)
      valueToDecompress = pako.inflate(valueToDecompress, { to: 'string' })
      return valueToDecompress
    }
    return null
  },
  // -------- Compresion de String

  // para autoregistro en Vue al momento de usar vue.use
  install (Vue, options) {
    if (!Vue.prototype.$functions) {
      Object.defineProperty(Vue.prototype, '$functions', {value: functions})
      _selfFunctions = functions
      if (window) {
        window.functions = functions
      }
    }
  }  
}

export default functions
